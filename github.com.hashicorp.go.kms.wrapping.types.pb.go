// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com.hashicorp.go.kms.wrapping.types.proto

package wrapping

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Envelope performs encryption or decryption, wrapping sensitive data. It
// creates a random key. This is usable on its own but since many KMS systems
// or key types cannot support large values, this is used by implementations in
// this package to encrypt large values with a DEK and use the actual KMS to
// encrypt the DEK.
type Envelope struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Envelope) Reset()         { *m = Envelope{} }
func (m *Envelope) String() string { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()    {}
func (*Envelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca191caf584e9474, []int{0}
}

func (m *Envelope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Envelope.Unmarshal(m, b)
}
func (m *Envelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Envelope.Marshal(b, m, deterministic)
}
func (m *Envelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Envelope.Merge(m, src)
}
func (m *Envelope) XXX_Size() int {
	return xxx_messageInfo_Envelope.Size(m)
}
func (m *Envelope) XXX_DiscardUnknown() {
	xxx_messageInfo_Envelope.DiscardUnknown(m)
}

var xxx_messageInfo_Envelope proto.InternalMessageInfo

// EnvelopeOptions is a placeholder for future options, such as the ability to
// switch which algorithm is used
type EnvelopeOptions struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvelopeOptions) Reset()         { *m = EnvelopeOptions{} }
func (m *EnvelopeOptions) String() string { return proto.CompactTextString(m) }
func (*EnvelopeOptions) ProtoMessage()    {}
func (*EnvelopeOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca191caf584e9474, []int{1}
}

func (m *EnvelopeOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvelopeOptions.Unmarshal(m, b)
}
func (m *EnvelopeOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvelopeOptions.Marshal(b, m, deterministic)
}
func (m *EnvelopeOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvelopeOptions.Merge(m, src)
}
func (m *EnvelopeOptions) XXX_Size() int {
	return xxx_messageInfo_EnvelopeOptions.Size(m)
}
func (m *EnvelopeOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvelopeOptions.DiscardUnknown(m)
}

var xxx_messageInfo_EnvelopeOptions proto.InternalMessageInfo

// EnvelopeInfo contains the information necessary to perfom encryption or
// decryption in an envelope fashion
type EnvelopeInfo struct {
	// Ciphertext is the ciphertext from the envelope
	Ciphertext []byte `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	// Key is the key used in the envelope
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// IV is the initialization value used during encryption in the envelope
	IV                   []byte   `protobuf:"bytes,3,opt,name=iv,proto3" json:"iv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvelopeInfo) Reset()         { *m = EnvelopeInfo{} }
func (m *EnvelopeInfo) String() string { return proto.CompactTextString(m) }
func (*EnvelopeInfo) ProtoMessage()    {}
func (*EnvelopeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca191caf584e9474, []int{2}
}

func (m *EnvelopeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvelopeInfo.Unmarshal(m, b)
}
func (m *EnvelopeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvelopeInfo.Marshal(b, m, deterministic)
}
func (m *EnvelopeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvelopeInfo.Merge(m, src)
}
func (m *EnvelopeInfo) XXX_Size() int {
	return xxx_messageInfo_EnvelopeInfo.Size(m)
}
func (m *EnvelopeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvelopeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EnvelopeInfo proto.InternalMessageInfo

func (m *EnvelopeInfo) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EnvelopeInfo) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *EnvelopeInfo) GetIV() []byte {
	if m != nil {
		return m.IV
	}
	return nil
}

// EncryptedBlobInfo contains information about the encrypted value along with
// information about the key used to encrypt it
type EncryptedBlobInfo struct {
	// Ciphertext is the encrypted bytes
	Ciphertext []byte `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	// IV is the initialization value used during encryption
	IV []byte `protobuf:"bytes,2,opt,name=iv,proto3" json:"iv,omitempty"`
	// HMAC is the bytes of the HMAC, if any
	HMAC []byte `protobuf:"bytes,3,opt,name=hmac,proto3" json:"hmac,omitempty"`
	// Wrapped can be used by the client to indicate whether Ciphertext
	// actually contains wrapped data or not. This can be useful if you want to
	// reuse the same struct to pass data along before and after wrapping.
	Wrapped bool `protobuf:"varint,4,opt,name=wrapped,proto3" json:"wrapped,omitempty"`
	// KeyInfo contains information about the key that was used to create this value
	KeyInfo *KeyInfo `protobuf:"bytes,5,opt,name=key_info,json=keyInfo,proto3" json:"key_info,omitempty"`
	// ValuePath can be used by the client to store information about where the
	// value came from
	ValuePath            string   `protobuf:"bytes,6,opt,name=ValuePath,proto3" json:"ValuePath,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptedBlobInfo) Reset()         { *m = EncryptedBlobInfo{} }
func (m *EncryptedBlobInfo) String() string { return proto.CompactTextString(m) }
func (*EncryptedBlobInfo) ProtoMessage()    {}
func (*EncryptedBlobInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca191caf584e9474, []int{3}
}

func (m *EncryptedBlobInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptedBlobInfo.Unmarshal(m, b)
}
func (m *EncryptedBlobInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptedBlobInfo.Marshal(b, m, deterministic)
}
func (m *EncryptedBlobInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedBlobInfo.Merge(m, src)
}
func (m *EncryptedBlobInfo) XXX_Size() int {
	return xxx_messageInfo_EncryptedBlobInfo.Size(m)
}
func (m *EncryptedBlobInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedBlobInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedBlobInfo proto.InternalMessageInfo

func (m *EncryptedBlobInfo) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EncryptedBlobInfo) GetIV() []byte {
	if m != nil {
		return m.IV
	}
	return nil
}

func (m *EncryptedBlobInfo) GetHMAC() []byte {
	if m != nil {
		return m.HMAC
	}
	return nil
}

func (m *EncryptedBlobInfo) GetWrapped() bool {
	if m != nil {
		return m.Wrapped
	}
	return false
}

func (m *EncryptedBlobInfo) GetKeyInfo() *KeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *EncryptedBlobInfo) GetValuePath() string {
	if m != nil {
		return m.ValuePath
	}
	return ""
}

// KeyInfo contains information regarding which Wrapper key was used to
// encrypt the entry
type KeyInfo struct {
	// Mechanism is the method used by the wrapper to encrypt and sign the
	// data as defined by the wrapper.
	Mechanism     uint64 `protobuf:"varint,1,opt,name=Mechanism,proto3" json:"Mechanism,omitempty"`
	HMACMechanism uint64 `protobuf:"varint,2,opt,name=HMACMechanism,proto3" json:"HMACMechanism,omitempty"`
	// This is an opaque ID used by the wrapper to identify the specific key to
	// use as defined by the wrapper. This could be a version, key label, or
	// something else.
	KeyID     string `protobuf:"bytes,3,opt,name=KeyID,proto3" json:"KeyID,omitempty"`
	HMACKeyID string `protobuf:"bytes,4,opt,name=HMACKeyID,proto3" json:"HMACKeyID,omitempty"`
	// These value are used when generating our own data encryption keys
	// and encrypting them using the wrapper
	WrappedKey []byte `protobuf:"bytes,5,opt,name=WrappedKey,proto3" json:"WrappedKey,omitempty"`
	// Mechanism specific flags
	Flags                uint64   `protobuf:"varint,6,opt,name=Flags,proto3" json:"Flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyInfo) Reset()         { *m = KeyInfo{} }
func (m *KeyInfo) String() string { return proto.CompactTextString(m) }
func (*KeyInfo) ProtoMessage()    {}
func (*KeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca191caf584e9474, []int{4}
}

func (m *KeyInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyInfo.Unmarshal(m, b)
}
func (m *KeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyInfo.Marshal(b, m, deterministic)
}
func (m *KeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyInfo.Merge(m, src)
}
func (m *KeyInfo) XXX_Size() int {
	return xxx_messageInfo_KeyInfo.Size(m)
}
func (m *KeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KeyInfo proto.InternalMessageInfo

func (m *KeyInfo) GetMechanism() uint64 {
	if m != nil {
		return m.Mechanism
	}
	return 0
}

func (m *KeyInfo) GetHMACMechanism() uint64 {
	if m != nil {
		return m.HMACMechanism
	}
	return 0
}

func (m *KeyInfo) GetKeyID() string {
	if m != nil {
		return m.KeyID
	}
	return ""
}

func (m *KeyInfo) GetHMACKeyID() string {
	if m != nil {
		return m.HMACKeyID
	}
	return ""
}

func (m *KeyInfo) GetWrappedKey() []byte {
	if m != nil {
		return m.WrappedKey
	}
	return nil
}

func (m *KeyInfo) GetFlags() uint64 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func init() {
	proto.RegisterType((*Envelope)(nil), "github.com.hashicorp.go.kms.wrapping.types.Envelope")
	proto.RegisterType((*EnvelopeOptions)(nil), "github.com.hashicorp.go.kms.wrapping.types.EnvelopeOptions")
	proto.RegisterType((*EnvelopeInfo)(nil), "github.com.hashicorp.go.kms.wrapping.types.EnvelopeInfo")
	proto.RegisterType((*EncryptedBlobInfo)(nil), "github.com.hashicorp.go.kms.wrapping.types.EncryptedBlobInfo")
	proto.RegisterType((*KeyInfo)(nil), "github.com.hashicorp.go.kms.wrapping.types.KeyInfo")
}

func init() {
	proto.RegisterFile("github.com.hashicorp.go.kms.wrapping.types.proto", fileDescriptor_ca191caf584e9474)
}

var fileDescriptor_ca191caf584e9474 = []byte{
	// 371 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xcd, 0x4a, 0xfb, 0x40,
	0x14, 0xc5, 0x49, 0x9a, 0x7e, 0xdd, 0x7f, 0xff, 0x6a, 0x07, 0x17, 0x59, 0x88, 0x84, 0xe0, 0x22,
	0x08, 0x9d, 0x8a, 0x5d, 0xba, 0xb2, 0x5a, 0x51, 0x4a, 0xb5, 0xcc, 0x42, 0xc1, 0x8d, 0xa4, 0xe9,
	0x34, 0x19, 0xf2, 0x31, 0x43, 0x32, 0xad, 0xe6, 0xc9, 0x7c, 0x1c, 0x5f, 0x45, 0x32, 0x31, 0x4d,
	0xdd, 0xd5, 0xdd, 0xb9, 0xbf, 0xb9, 0x39, 0xdc, 0x73, 0x08, 0x5c, 0xf8, 0x4c, 0x06, 0xeb, 0x05,
	0xf6, 0x78, 0x8c, 0x03, 0x37, 0x0b, 0x98, 0xc7, 0x53, 0x81, 0x7d, 0x8e, 0xc3, 0x38, 0xc3, 0xef,
	0xa9, 0x2b, 0x04, 0x4b, 0x7c, 0x2c, 0x73, 0x41, 0x33, 0x2c, 0x52, 0x2e, 0x39, 0x3a, 0xdf, 0xff,
	0x0b, 0x1b, 0xa0, 0x33, 0x49, 0x36, 0x34, 0xe2, 0x82, 0xda, 0x7d, 0x38, 0xac, 0xf4, 0x93, 0x90,
	0x8c, 0x27, 0x99, 0x3d, 0x87, 0x5e, 0x85, 0x1e, 0x92, 0x15, 0x47, 0xa7, 0x00, 0x1e, 0x13, 0x01,
	0x4d, 0x25, 0xfd, 0x90, 0xa6, 0x66, 0x69, 0x4e, 0x8f, 0xec, 0x10, 0x74, 0x04, 0x8d, 0x90, 0xe6,
	0xa6, 0xae, 0x1e, 0x0a, 0x89, 0x0e, 0x40, 0x67, 0x1b, 0xb3, 0xa1, 0x80, 0xce, 0x36, 0xf6, 0x97,
	0x06, 0xfd, 0x49, 0xe2, 0xa5, 0xb9, 0x90, 0x74, 0x39, 0x8e, 0xf8, 0x62, 0x2f, 0xdf, 0xd2, 0x45,
	0xaf, 0x5c, 0x10, 0x02, 0x23, 0x88, 0x5d, 0xef, 0xc7, 0x57, 0x69, 0x64, 0x42, 0x5b, 0x85, 0xa3,
	0x4b, 0xd3, 0xb0, 0x34, 0xa7, 0x43, 0xaa, 0x11, 0x3d, 0x42, 0x27, 0xa4, 0xf9, 0x1b, 0x4b, 0x56,
	0xdc, 0x6c, 0x5a, 0x9a, 0xf3, 0xef, 0x72, 0x84, 0xff, 0xd0, 0xea, 0x94, 0xe6, 0xc5, 0x91, 0xa4,
	0x1d, 0x96, 0x02, 0x9d, 0x40, 0xf7, 0xd9, 0x8d, 0xd6, 0x74, 0xee, 0xca, 0xc0, 0x6c, 0x59, 0x9a,
	0xd3, 0x25, 0x35, 0xb0, 0x3f, 0x35, 0x68, 0x4f, 0xeb, 0xcd, 0x19, 0xf5, 0x02, 0x37, 0x61, 0x59,
	0xac, 0x62, 0x19, 0xa4, 0x06, 0xe8, 0x0c, 0xfe, 0xdf, 0xcf, 0xae, 0x6f, 0xea, 0x0d, 0x5d, 0x6d,
	0xfc, 0x86, 0xe8, 0x18, 0x9a, 0x85, 0xdd, 0xad, 0x0a, 0xdb, 0x25, 0xe5, 0x50, 0x38, 0x17, 0x6b,
	0xe5, 0x8b, 0x51, 0xde, 0xb0, 0x05, 0x45, 0x9f, 0x2f, 0x65, 0xf8, 0x29, 0xcd, 0x55, 0xe6, 0x1e,
	0xd9, 0x21, 0x85, 0xe7, 0x5d, 0xe4, 0xfa, 0x99, 0xba, 0xde, 0x20, 0xe5, 0x30, 0x1e, 0xbe, 0x0e,
	0xea, 0x5a, 0x86, 0xdb, 0x5a, 0x86, 0x3e, 0x1f, 0x84, 0x71, 0x36, 0xa8, 0x6a, 0xb9, 0xaa, 0xc4,
	0xa2, 0xa5, 0x7e, 0xb8, 0xd1, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xde, 0x4b, 0xdb, 0x55, 0xa4,
	0x02, 0x00, 0x00,
}
